use std::{
    fs::File,
    io::{BufWriter, Error, ErrorKind, Result, Seek},
};

use crate::{bytes_ext::ReadBytesExt, chunks::BitmapData, reader::Reader};

#[derive(Debug)]
pub struct Bitmap {
    pub info: BitmapInfo,
}

#[derive(Debug)]
pub struct BitmapInfo {
    pub pitch: u16,
    pub height: u16,
    pub width: u16,
    pub reg_y: i16,
    pub reg_x: i16,
    pub bit_depth: u8,
    pub palette_id: i16,
}

impl Bitmap {
    pub fn export(&self, filename: &str, data: &BitmapData) -> Result<()> {
        let buf = data.buf();
        let r = Reader::new(buf);

        if self.info.bit_depth == 8 {
            let Ok(len) = decompress_len(r.clone()) else {
                return Ok(());
            };

            let mut data = vec![0; len].into_boxed_slice();
            decompress(r, &mut data)?;

            let width = self.info.pitch as u32;
            let height = len as u32 / width;

            println!(
                "width = {:#5x}, height = {:#5x}, decompressed len = {:#7x}",
                width, height, len
            );

            let f = File::create(filename)?;
            let mut w = BufWriter::new(f);

            let mut pixel_data = Vec::with_capacity((width * height * 3) as usize);

            for y in 0..height {
                for x in 0..width {
                    let pi = (y * width + x) as usize;
                    let pc = data[pi] as usize;
                    let p = [
                        MAC_PALLETE[3 * pc],
                        MAC_PALLETE[3 * pc + 1],
                        MAC_PALLETE[3 * pc + 2],
                    ];
                    pixel_data.extend_from_slice(&p);
                }
            }
            let mut encoder = png::Encoder::new(w, width, height);
            encoder.set_color(png::ColorType::Rgb);
            encoder.set_depth(png::BitDepth::Eight);

            let mut writer = encoder.write_header()?;

            writer.write_image_data(&pixel_data)?;
            writer.finish()?;
        }

        Ok(())
    }
}

impl BitmapInfo {
    pub fn read(r: Reader, _id: u32) -> Result<Self> {
        let mut r = r;

        r.hex_dump()?;

        let a = r.read_be_u16()?;
        let pitch = a & 0xfff;
        let _ = r.read_u8()?;
        let _ = r.read_u8()?;
        let _ = r.read_u8()?;
        let _ = r.read_u8()?;

        let height = r.read_be_u16()?;
        let width = r.read_be_u16()?;
        let _ = r.read_be_u16()?;
        let _ = r.read_be_u16()?;
        let _ = r.read_be_u16()?;
        let _ = r.read_be_u16()?;
        let reg_y = r.read_be_i16()?;
        let reg_x = r.read_be_i16()?;
        let _ = r.read_u8().unwrap_or_default();
        let bit_depth = r.read_u8().unwrap_or(1);
        let _ = r.read_be_i16().unwrap_or_default();
        let palette_id = r.read_be_i16().unwrap_or(1) - 1;

        Ok(BitmapInfo {
            pitch,
            height,
            width,
            reg_y,
            reg_x,
            bit_depth,
            palette_id,
        })
    }
}

fn decompress_len(r: Reader) -> Result<usize> {
    let mut r = r;
    let mut remain = r.stream_len()? as usize;
    let mut output_len = 0;

    while remain != 0 {
        let b = r.read_u8()?;
        remain -= 1;

        if b & 0x80 != 0 {
            let len = 257 - (b as usize);

            if remain < 1 {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "decompress_len: Unable to decompress",
                ));
            }

            output_len += len;
            remain -= 1;
            r.seek_relative(1)?;
        } else {
            let len = b as usize + 1;

            if remain < len {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "decompress_len: Unable to decompress",
                ));
            }

            output_len += len;
            remain -= len;
            r.seek_relative(len as i64)?;
        }
    }

    Ok(output_len)
}

fn decompress(r: Reader, buf: &mut [u8]) -> Result<()> {
    let mut r = r;
    let mut dst_pos = 0;

    while let Ok(b) = r.read_u8() {
        if b & 0x80 != 0 {
            let len = 257 - (b as usize);

            let v = r.read_u8()?;
            for _ in 0..len {
                buf[dst_pos] = v;
                dst_pos += 1;
            }
        } else {
            let len = b as usize + 1;

            for _ in 0..len {
                buf[dst_pos] = r.read_u8()?;
                dst_pos += 1;
            }
        }
    }

    Ok(())
}

#[rustfmt::skip]
static MAC_PALLETE: [u8; 768] = [
    0xff, 0xff, 0xff, 0x00, 0x69, 0xff, 0x00, 0x63, 0xff, 0x00, 0x5d, 0xff,
    0x00, 0x56, 0xff, 0x00, 0x50, 0xff, 0x00, 0x4a, 0xff, 0x00, 0x43, 0xff,
    0x00, 0x3d, 0xff, 0x00, 0x36, 0xff, 0x00, 0x30, 0xff, 0x00, 0x2a, 0xff,
    0x00, 0x23, 0xff, 0x00, 0x1d, 0xff, 0x00, 0x17, 0xff, 0x00, 0x10, 0xff,
    0x00, 0x0a, 0xff, 0x00, 0x03, 0xff, 0x06, 0x00, 0xff, 0x0c, 0x00, 0xff,
    0x13, 0x00, 0xff, 0x19, 0x00, 0xff, 0x1f, 0x00, 0xff, 0x26, 0x00, 0xff,
    0x2c, 0x00, 0xff, 0x33, 0x00, 0xff, 0x39, 0x00, 0xff, 0x3f, 0x00, 0xff,
    0x46, 0x00, 0xff, 0x4c, 0x00, 0xff, 0x52, 0x00, 0xff, 0x59, 0x00, 0xff,
    0x5f, 0x00, 0xff, 0x66, 0x00, 0xff, 0x6c, 0x00, 0xff, 0x72, 0x00, 0xff,
    0x79, 0x00, 0xff, 0x7f, 0x00, 0xff, 0x85, 0x00, 0xff, 0x8c, 0x00, 0xff,
    0x92, 0x00, 0xff, 0x99, 0x00, 0xff, 0x9f, 0x00, 0xff, 0xa5, 0x00, 0xff,
    0xac, 0x00, 0xff, 0xb2, 0x00, 0xff, 0xb8, 0x00, 0xff, 0xbf, 0x00, 0xff,
    0xc5, 0x00, 0xff, 0xcc, 0x00, 0xff, 0xd2, 0x00, 0xff, 0xd8, 0x00, 0xff,
    0xdf, 0x00, 0xff, 0xe5, 0x00, 0xff, 0xeb, 0x00, 0xff, 0xf2, 0x00, 0xff,
    0xf8, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xf8, 0xff, 0x00, 0xf2,
    0xff, 0x00, 0xeb, 0xff, 0x00, 0xe5, 0xff, 0x00, 0xdf, 0xff, 0x00, 0xd8,
    0xff, 0x00, 0xd2, 0xff, 0x00, 0xcc, 0xff, 0x00, 0xc5, 0xff, 0x00, 0xbf,
    0xff, 0x00, 0xb8, 0xff, 0x00, 0xb2, 0xff, 0x00, 0xac, 0xff, 0x00, 0xa5,
    0xff, 0x00, 0x9f, 0xff, 0x00, 0x99, 0xff, 0x00, 0x92, 0xff, 0x00, 0x8c,
    0xff, 0x00, 0x85, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x79, 0xff, 0x00, 0x72,
    0xff, 0x00, 0x6c, 0xff, 0x00, 0x66, 0xff, 0x00, 0x5f, 0xff, 0x00, 0x59,
    0xff, 0x00, 0x52, 0xff, 0x00, 0x4c, 0xff, 0x00, 0x46, 0xff, 0x00, 0x3f,
    0xff, 0x00, 0x39, 0xff, 0x00, 0x33, 0xff, 0x00, 0x2c, 0xff, 0x00, 0x26,
    0xff, 0x00, 0x1f, 0xff, 0x00, 0x19, 0xff, 0x00, 0x13, 0xff, 0x00, 0x0c,
    0xff, 0x00, 0x06, 0xff, 0x00, 0x00, 0xff, 0x06, 0x00, 0xff, 0x0c, 0x00,
    0xff, 0x13, 0x00, 0xff, 0x19, 0x00, 0xff, 0x1f, 0x00, 0xff, 0x26, 0x00,
    0xff, 0x2c, 0x00, 0xff, 0x33, 0x00, 0xff, 0x39, 0x00, 0xff, 0x3f, 0x00,
    0xff, 0x46, 0x00, 0xff, 0x4c, 0x00, 0xff, 0x52, 0x00, 0xff, 0x59, 0x00,
    0xff, 0x5f, 0x00, 0xff, 0x66, 0x00, 0xff, 0x6c, 0x00, 0xff, 0x72, 0x00,
    0xff, 0x79, 0x00, 0xff, 0x7f, 0x00, 0xff, 0x85, 0x00, 0xff, 0x8c, 0x00,
    0xff, 0x92, 0x00, 0xff, 0x99, 0x00, 0xff, 0x9f, 0x00, 0xff, 0xa5, 0x00,
    0xff, 0xac, 0x00, 0xff, 0xb2, 0x00, 0xff, 0xb8, 0x00, 0xff, 0xbf, 0x00,
    0xff, 0xc5, 0x00, 0xff, 0xcc, 0x00, 0xff, 0xd2, 0x00, 0xff, 0xd8, 0x00,
    0xff, 0xdf, 0x00, 0xff, 0xe5, 0x00, 0xff, 0xeb, 0x00, 0xff, 0xf2, 0x00,
    0xff, 0xf8, 0x00, 0xff, 0xff, 0x00, 0xf8, 0xff, 0x00, 0xf2, 0xff, 0x00,
    0xeb, 0xff, 0x00, 0xe5, 0xff, 0x00, 0xdf, 0xff, 0x00, 0xd8, 0xff, 0x00,
    0xd2, 0xff, 0x00, 0xcc, 0xff, 0x00, 0xc5, 0xff, 0x00, 0xbf, 0xff, 0x00,
    0xb8, 0xff, 0x00, 0xb2, 0xff, 0x00, 0xac, 0xff, 0x00, 0xa5, 0xff, 0x00,
    0x9f, 0xff, 0x00, 0x99, 0xff, 0x00, 0x92, 0xff, 0x00, 0x8c, 0xff, 0x00,
    0x85, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x79, 0xff, 0x00, 0x72, 0xff, 0x00,
    0x6c, 0xff, 0x00, 0x66, 0xff, 0x00, 0x5f, 0xff, 0x00, 0x59, 0xff, 0x00,
    0x52, 0xff, 0x00, 0x4c, 0xff, 0x00, 0x46, 0xff, 0x00, 0x3f, 0xff, 0x00,
    0x39, 0xff, 0x00, 0x33, 0xff, 0x00, 0x2c, 0xff, 0x00, 0x26, 0xff, 0x00,
    0x1f, 0xff, 0x00, 0x19, 0xff, 0x00, 0x13, 0xff, 0x00, 0x0c, 0xff, 0x00,
    0x06, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x06, 0x00, 0xff, 0x0c,
    0x00, 0xff, 0x13, 0x00, 0xff, 0x19, 0x00, 0xff, 0x1f, 0x00, 0xff, 0x26,
    0x00, 0xff, 0x2c, 0x00, 0xff, 0x33, 0x00, 0xff, 0x39, 0x00, 0xff, 0x3f,
    0x00, 0xff, 0x46, 0x00, 0xff, 0x4c, 0x00, 0xff, 0x52, 0x00, 0xff, 0x59,
    0x00, 0xff, 0x5f, 0x00, 0xff, 0x66, 0x00, 0xff, 0x6c, 0x00, 0xff, 0x72,
    0x00, 0xff, 0x79, 0x00, 0xff, 0x7f, 0x00, 0xff, 0x85, 0x00, 0xff, 0x8c,
    0x00, 0xff, 0x92, 0x00, 0xff, 0x99, 0x00, 0xff, 0x9f, 0x00, 0xff, 0xa5,
    0x00, 0xff, 0xac, 0x00, 0xff, 0xb2, 0x00, 0xff, 0xb8, 0x00, 0xff, 0xbf,
    0x00, 0xff, 0xc5, 0x00, 0xff, 0xcc, 0x00, 0xff, 0xd2, 0x00, 0xff, 0xd8,
    0x00, 0xff, 0xdf, 0x00, 0xff, 0xe5, 0x00, 0xff, 0xeb, 0x00, 0xff, 0xf2,
    0x00, 0xff, 0xf8, 0x00, 0xff, 0xff, 0x00, 0xf8, 0xff, 0x00, 0xf2, 0xff,
    0x00, 0xeb, 0xff, 0x00, 0xe5, 0xff, 0x00, 0xdf, 0xff, 0x00, 0xd8, 0xff,
    0x00, 0xd2, 0xff, 0x00, 0xcc, 0xff, 0x00, 0xc5, 0xff, 0x00, 0xbf, 0xff,
    0x00, 0xb8, 0xff, 0x00, 0xb2, 0xff, 0x00, 0xac, 0xff, 0x00, 0xa5, 0xff,
    0x00, 0x9f, 0xff, 0x00, 0x99, 0xff, 0x00, 0x92, 0xff, 0x00, 0x8c, 0xff,
    0x00, 0x85, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x79, 0xff, 0x00, 0x72, 0xff,
    0xf0, 0xf0, 0xf0, 0xe0, 0xe0, 0xe0, 0xd0, 0xd0, 0xd0, 0xc0, 0xc0, 0xc0,
    0xb0, 0xb0, 0xb0, 0xa0, 0xa0, 0xa0, 0x90, 0x90, 0x90, 0x80, 0x80, 0x80,
    0x70, 0x70, 0x70, 0x60, 0x60, 0x60, 0x50, 0x50, 0x50, 0x40, 0x40, 0x40,
    0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
];
